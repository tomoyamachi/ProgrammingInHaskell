* 12章 遅延評価
** 評価の概念と、二つの評価戦略
*** 1.導入
関数は、関数適用の順番を変えても最終的な結果に影響ない。
? 複数の射を組み合わせても、最後には同じ対象に行きつくイメージ ?


命令型言語の多くは、値を蓄積するので、変数への代入のタイミングが計算結果に影響する。
Haskellでは、引数への関数適用のタイミングは、計算結果に影響しない。

命令型ex)
: n = 0
: n + (n = 1)
このとき左の式を先に代入すると
: 1 + 1
右の代入を先に評価すると
: 0 + 1
となり値が変わることがわかる。


*** 2.評価戦略
1つ以上の引数が適用されている関数、かつ、簡約可能な式を簡約可能式(リデックス)と呼ぶ。
簡約には順番があり、おおきく分けて、最内簡約と最外簡約がある。

**** 最内簡約 値渡し
単純で一般的な戦略。
他の簡約可能式を含まない、内側の式から評価していく。
同じ階層で、2つ式があれば、左から評価。

引数は適用前に評価され、渡される。
つまり、引数は値として渡され、値を関数に適用する。(値渡し)

**** 最外簡約 名前渡し
最内簡約の逆に、外側の式から評価していく。
Haskellの場合は、最外評価を採用している。

引数は名前として渡される。(名前渡し)
渡された名前が式だった場合、その式を評価する。

**** 簡約と\式
Haskellにおいてλ式は、式内の簡約可能式を選択できない。
? なぜ「禁止されている」という表現なのか ?

理由
1.λ式は関数である。
2.関数は引数を与え、その引数を適用することしかできない(ブラックボックスとして存在)
3.関数の本体を簡約するとしたら、関数が適用されたあと

よって、λ式は、式内の簡約可能式を選択できない。

*** 戦略の比較1. 停止性
: inf :: Int
: inf = 1 + inf
という関数infがある場合、
: fst (x,y) = x
: fst (0,inf)
で定義されるfstを適用する。
以下の結果から、評価を多く停止させるには、名前渡しの方が適している。

**** 最内簡約の場合(値渡し)
値を渡さなければならないので、infを再帰的に繰り返さなければならない。

**** 最外簡約の場合(名前渡し)
infを関数ではなく名前として見るため、「0」が返る。
式を停止させる手順が存在するなら、評価を必ず停止させ、同じ結果を返すことができる

*** 戦略の比較2. 簡約の回数
: square :: Int -> Int
: square n = n * n
という関数squareがある。
このとき、nに関数が入ると、名前渡しは値渡しよりも、計算回数が増える。

: square (1+2)
値渡し
: square 3

名前渡し
: (1+2) * (1+2)

しかし、共有される式をポインタで指せば、効率は変わらなくなる。

*** まとめ
Haskellは、停止性を高めるために名前渡しをし、効率の悪さを克服するために、共有される式はポインタで指すことになっている。
これを遅延評価と呼ぶ。

** 無限のデータ構造、部品プログラミング
*** 5.無限のデータ構造
: ones :: [Int]
: ones = 1:ones
遅延評価の下では、上のようなonesは無限リストではなく、
要求される回数だけ評価される「潜在的な」無限リストとなる。

: head ones
: head (1:ones) #=> 1
*** 6.部品プログラミング
遅延評価では、計算のときデータから制御を切り離すことができる。
: take 3 ones
: take 3 (1:ones)
: 1:take 2 ones
: 1:take 2 (1:ones)
: 1:1:take 1 ones
: 1:1:take 1 (1:ones)
: 1:1:1:take 0 ones
: 1:1:1:[]

となり、1の無限リスト(データ)からtake 3(制御)は切り離され、それぞれが交互に機能していることがわかる。

** 正格適用($!)
Haskellでは遅延評価を用いず、関数適用を正格適用することもできる。演算子は($!)。

f $! x は、xが関数だった場合は計算してから、fが適用される。

*** 使い道
作業空間の効率化(メモリー枯渇させない)


