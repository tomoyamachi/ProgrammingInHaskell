* 第1章
** 1_1 関数
    関数は「一つ以上の引数を取り、一つの結果を返す変換」できる。
    関数を適用する順番は、結果に影響を与えない!
** 1_2 関数プログラミング
    関数プログラミングは「計算とは関数を引数に適用することだ」という視点(*)
    命令型言語は「計算の基本は蓄えられている値を変えること」という視点(*)
    *用語の定義は人によって違う。

*** (命令 in ruby)
      def get_total(n)
        count = 0#命令してる
        total = 0#命令してる
        while count < n
          count += 1
          total += count
          #totalとcountの値が変化しているのがわかる。
        end
        total
      end
    命令型言語は関数プログラミングを制限しているものが多い。
    Haskellは関数の利用に制約はない。

*** (関数 in rubyだとこうなんのか??injectは制約ない気がする)
      def get_total(n)
        total = (0..n).inject(0){|count,i| count + i}
      end

** 1_3 Haskellの特徴
    簡潔なプログラム
        少ないキーワード
        インデントによる構造化
    強力な型システム
        型推論+「多相型」「多重定義型」
    リスト内包表記
        一つ以上のリストから要素を選択、加工することで、新しいリストをつくる。
    再帰関数
        自分をつかって自分を定義
    高階関数
        引数として関数を取る。||返り値として関数を返す。
    モナド
    遅延評価
    プログラムの論証
** 1_5 Haskellの妙味
    クイックソート
      qsort[] = []
      qsort(x:xs) = qsort smaller ++ [x] ++ qsort larger
        where
          smaller = [a|a<-xs,a<=x]
          larger = [b|b<-xs,b>x]

    qsortの型は「qsort::Ord a => [a] -> [a]」。
    Ordとは、Ordering型(任意の順序型)。

* 第2章 はじめの一歩
2_1 Hugs
** 2_2 標準ライブラリ
    Prelude.hsという標準ライブラリを起動時に読みこむ。

    演算子
        +
        -
        *
        ^
        `div`
    リスト操作
        head
        tail
        [1,2,3]!!n
        take n [1,2,3]
        drop n [1,2,3]
        length
        sum
        product
        ++
        reverse
** 2_3 関数適用(ひむらさんのをコピペ)
     | 数学       | haskell(ghc?) | 別解           |
     |------------+---------------+---------------|
     |------------+---------------+---------------|
     | f(x)       | f x           |               |
     |------------+---------------+---------------|
     | f(x,y)     | f x y         |               |
     |------------+---------------+---------------|
     | f(g(x))    | f (g x)       | f $ g x       |
     |------------+---------------+---------------|
     | f(x, g(x)) | f x (g x)     | f x $ g x     |
     |------------+---------------+---------------|
     | f(x)g(x)   | f x * g x     | (f x) * (g x) |
** 2_4 Haskellプログラム
    ghci(hugs)でのコマンド
        :l filename => load filename
        :r => reload current file
        :t expr => show expr's type
        :? => help
    レイアウト規則 - 行頭揃えによって定義をグループ化できる
    コメント
        一行コメント --
        囲みコメント {- ここになんかかく -}

* 第3章 型とクラス
** 3_1 基本概念
    型とは、互いに関連する値の集合。
    v::Tは「vの型はTである」という意味。
    Haskellでは、「すべての式は型を持たなければならない」!!
    式の型は、型推論によって、式を評価する前に決まる。
** 3_2 基本型
    Bool ー 真理値
    Char ー 文字。シングルクオートで囲む。制御文字を値として持つ。
    String ー 文字列。ダブルクオート。
    Int ー 固定精度整数。 -2^31 <= Int <= (2^31 -1)
    Integer ー 多倍長整数。
    Float ー 単精度浮動小数点数。
** 3_3 リスト型
    リストとは「同じ型の要素の並び」。
    表記は、[]で囲まれ、コンマで区切る。
    T型の要素をもつリストの型は、[T]と書く。
** 3_4 タプル型
    タプルとは「有限個の要素の組」。各要素の型が異なってもよい。
    表記は、()で囲まれ、コンマで区切る。
3_5 関数型
** 3_6 カリー化された関数
    関数は「ある型の引数を他の型の結果に変換する」!!
    型T1の引数を、型T2に変換すると、「T1 -> T2」
    複数の引数を取ろうと思ったら、
    タプルを引数にする。
    (ex)
        add ::(Int,Int) -> Int
        add (x,y) = x + y
    関数をカリー化する。
    (ex)
        add' ::Int -> Int -> Int
        add' x y = x + y
        -- ::Int -> Int -> Int は ::Int -> (Int -> Int)を表す。
** 3_7 多相型
    たとえばlengthは、リスト内の型がなんであろうと、Intを出力する。このとき
    length::[a] -> Int
    と表記し、lengthは多相関数である、と言える。
** 3_8 多重定義型
    たとえば(+)は、Numクラスのインスタンスの型aに対し有効である。
    Numクラスのインスタンスとは、Numクラスの制約を満たすよう定義した型(Int,Floatなど)である。
    このとき、
    (+):: Num a => a -> a -> a
    と表記する。
    このように一つ以上のクラス制約を持つ型を、多重定義型と呼ぶ。
    *** => は 「クラス制約」、-> は「変換する」ことを意味する。
** 3_9 基本クラス
    Eq ー 同等クラス。
       (==)::a -> a -> Bool
       (/=)::a -> a -> Bool
    Ord ー 順序クラス。
        <::a -> a -> Bool
        >::a -> a -> Bool
        <=::a -> a -> Bool
        >=::a -> a -> Bool
        min ::a -> a -> a
        max ::a -> a -> a
    Show ー 表示可能クラス。文字列に変換可能なクラス。
    Read ー 読込可能クラス。文字列を値へ変換可能なクラス。(Showの対)
         read "123"::Float -- => 123.0
    Num ー 数値クラス。
    Integral ー 整数クラス。
    Fractional ー 分数クラス。

* 第4章 関数定義
** 4_1 古きから新しきへ
** 4_2 条件式
** 4_2 ガード付きの等式
    以下の2つの式は同値
        abs::Int->Int
        abs n = if n >= 0 then n else -n

        abs n | n >= 0  = 0
              | otherwise = -n b

** 4_4 パターンマッチ
    パターンが並べられ、列挙された同じ型の候補の中から結果を選ぶ
    たとえば (&&) は以下のような定義
        (&&) :: Bool -> Bool ->Bool
        True && True = True
        _ && _ = False
    (「_」はワイルドカード)

    タブルパターン
        「同じ要素数を持ち、それぞれの要素が対応するパターンにすべて合致するタプル」に合致
        ex)
            fst ::(a,b) -> a
            fst (x,_)

    リストパターン
        「同じ要素数をもち、それぞれの要素が対応するパターンにすべて合致するリスト」に合致
        [1,2,3] == 1:[2,3] == 1:2:3:[]なので

    n+kパターン
        pred :: Int -> Int
        pred 0 = 0
        pred (n + 1) = n
** 4_5 lambda(\)式=
    無名関数のこと。
    利用方法
        たとえば
            twice x = x + x
            twice 2
        を
            (\x -> x + x) 2
        と名前を付けて利用することができる.

        複数の引数をとりたいときは
            \ x y -> x + y

        カリー化された関数の形式的な意味づけ。以下の2つの式は同等
            add x y = x + y
            --
            add = \x -> (\y -> x + y)
            --引数にxを取り,ある関数を返す.その関数は,引数として数値yを取り(x+y)を返す.
        本質的に関数を返す関数を定義する場合、分かりやすい。
            const :: a -> b -> a
            const x _ = x 関数を返せる!!
            これでもわかるけど。。。
            const :: a -> (b -> a)
            const x = \_ -> x
            このほうが関数を返すっていうのがわかりやすい!!
        関数に名前を付けたくないとき。以下の2つの式は同等
            odds ::Int -> [Int]
            odds n = map f [0..n-1]
                     where f x = x * 2 + 1

            odds n = map (\x -> x * 2 + 1) [0..n-1]

** 4_6 セクション
    セクションとは、以下のような式のこと。(演算子はセクション)
        (@) = \x -> (\y -> x @ y)
        (x @) = \y -> x @ y
        (@ y) = \x -> x @ y

* 第5章 リスト内包表記
** 5_1 生成器
    内包表記ー既存の集合から、新しい集合を生成する
    xを集合{1,2,3,4}とするとき、すべての要素に対してx^2となる集合を生成するには
        [x^2|x<-[1..4]]
    と書く。(rubyなら、 [1,2,3,4].map{|x} x*x}みたいなもんか)

    「|」は「ーーのような」、「<-」は「ーーから取り出した」という意味。

    こんなんもできる
        > [(x,y)|x<-[1,2,3],y<-[4,5]]
        [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]

*** lengthの定義
        length ::[a]->Int
        length xs = sum [1|_<-xs]
        -- 「_<-xs」は1を要素分生成するためのカウンタ

** 5_2 ガード
    ガードは、前方の生成器で生成された値を、後方のガード(条件付けみたいなとこ)で間引く。
    ガードがTrueの場合、その値は残される。
    たとえば正の整数の約数をリストで返すメソッドは
        factors :: Int -> [Int]
        factors n = [x| x <- [1..n],mod n x == 0]

    以下のような動作をするfindValueメソッドを作るばあい。
        > findValue 'b' [('a',1),('b',2),('b',3)]
        [2,3]
    こんなかんじ。
        findValue :: Eq a => a -> [(a,b)] -> [b]
        findValue key list = [value|(key',value) <- list,key == key']

** 5_3 関数zip
    > zip ['a','b','c'][1,2,3,4]
    [('a',1),('b',2),('c',3)]
    リスト内包表記と一緒につかうと便利。

** 5_4 文字列の内包表記
    「"abc"::String」は「['a','b','c']::[Char]」の略記。
    > zip ['a','b','c'][1,2,3,4]
    は
    > zip "abc" [1,2,3,4]
    と同値。

** 5_5 シーザー暗号

* 第6章 再帰関数

** 6_1 基本概念
    関数を関数自身をつかって定義すること
        factorial 0 = 1 -- 基底部
        factorial (n+1) = (n + 1) * factorial n --再帰部

    haskellのライブラリ関数のほとんどが再帰。

** 6_2 リストに対する再帰
    たとえばreverseを定義すると、以下のようになる。
        reverse ::[a]->[a]
        reverse [] = []
        reverse (x:xs) = reverse xs ++ [x]

    ガードをつかうとこんなんもできる。
        insert ::Ord a => a -> [a] -> [a]
        insert x [] = [x]
        insert x (y:ys) | x <= y  = x : y : ys
                        | otherwise = y : insert x ys

** 6_3 複数の引数
    複数の引数を同時に変化させる場合、基底部が2つ必要になる。
        > dropRecur 6 [1,2,3,4,5,6,7,8]
        [7,8]
    を定義すると
        dropRecur :: Int -> [a] -> [a]
        dropRecur 0 xs = xs
        dropRecur n [] = []
        dropRecur n (_:xs) = dropRecur (n-1) xs

** 6_4 多重再帰
    関数が自分自身を複数参照すること。

** 6_5 相互再帰
    二つ以上の関数が、お互いを参照しあうこと。
        evenRecur ::Int ->Bool
        evenRecur 0 = True
        evenRecur n = oddRecur (n-1)

        oddRecur ::Int -> Bool
        oddRecur 0 = False
        oddRecur n = evenRecur (n-1)
    このときの動作は、evenRecurとoddRecurを繰りかえし、どちらの関数で0になるかにより返す値が変わる

** 6_6 再帰の秘訣
    6_3のdropRecurを例としてみていくと、、、

*** 1 型を定義する
      dropRecur :: Int -> [a] -> [a]

*** 2 場合分けをする
      dropRecur 0 [] =
      dropRecur 0 (x:xs) =
      dropRecur n [] =
      dropRecur n (x:xs) =

*** 3 簡単な方を定義する
      dropRecur 0 [] = []
      dropRecur 0 (x:xs) = x:xs
      dropRecur n [] = []
      dropRecur n (x:xs) =

*** 4 複雑な方を定義する
      dropRecur 0 [] = []
      dropRecur 0 (x:xs) = x:xs
      dropRecur n [] = []
      dropRecur n (x:xs) = dropRecur (n-1) xs

*** 5 一般化し単純にする
      利用されていない変数を「_」に変更
      重複を消去すると、6_3のようになる
